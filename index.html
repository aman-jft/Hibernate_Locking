<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">

<head>
  <title>How to perform hibernate locking?</title>
  <meta name="description" content="There are two strategies of performing hibernate locking i.e. Optimistic and Pessimistic. Both these strategies are explained in this post through the code." />
  <meta name="keywords" content="hibernate locking" />
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" type="text/css" href="css/style.css" />
<style>
div{
text-align:justify;
}
</style>
</head>
<body>
  
    <div id="site_content">		

	  <div id="banner_image">
	    <div id="slider-wrapper">        
          
            <img src="images/home_1.jpg" alt="" />
            
		 
		</div><!--close slider_wrapper-->
	  </div><!--close banner_image-->	

	  <div class="sidebar_container">       
		    		
		<div class="sidebar">
          <div class="sidebar_item">
           <h2> GitHub Link</h2> 
           <div class="imgBox"><p align="right"> 
            <a href="https://github.com/aman-jft/Hibernate_Locking"> <img src="images/download.png" alt="Download Sample Code" /></a>     </p></div>  
		  </div><!--close sidebar_item--> 
        </div><!--close sidebar-->
				
      </div><!--close sidebar_container-->		  
	 
	  <div id="content">
        <div class="content_item">
		  <h1>Hibernate Locking</h1> 
	      <p>Hibernate provides two strategies of locking for performing secure read/write operations. Hibernate achieves this by database locking mechanism and abstains locking object in memory. So, basically hibernate locking depends on database for there operations. The two terms involved are as follows :</p>	  
		  <div class="content_item"><h3>Optimistic</h3>
		    <p>This is used by hibernate to prevent from updating the record which is already modified in database. The approach says that there will be a column in table which explains the state of record called Version. It is usually a integer value which increments when the record is modified. By annotating the int type property of a persistence class with @Version will help hibernate to identify the version field.
Hibernate simply compares the value of version field. If the updating record has version value less the the database record value, then it will throw an exception :

<br>
<b>org.hibernate.StaleObjectStateException: Row was updated or deleted by another transaction (or unsaved-value mapping was incorrect)</b><br/>
Instead of int value, we can use Timestamp for same. Just define a property of Date type and annotate it with @Version. Now, the field will store the date & time when a new record is to create or modify the existing one, and also served the functionality of validating state of record.</p>
		  	
		  </div><!--close content_container-->
          <div class="content_item"><h3>Pessimistic</h3>
		    <p>The above approach did not provide the proper locking in terms of database. It was just to prevent database to update dirty records. In concurrently reading and updating data, it will always cause error because most of the time threads will pick the records which have been updated by another threads. In these type of cases, we need to lock the record so that no other transaction will access it until the current transaction gets complete. We use <b>LockMode.UPGRADE</b> to perform hibernate locking in parallel transaction mode.</p>          
		  			  
		  </div><!--close content_container-->		
		  
</body>
</html>
